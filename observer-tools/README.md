# Утилита наблюдателя

Утилита используется для выполнения криптографических проверок корректности учета бюллетеней и подведения итогов голосования. По файловым выгрузкам из блокчейн восстанавливает историю проведения голосования, проверяет корректность учтенных бюллетеней, основываясь на сохраненных в транзакциях доказательствах корректности зашифрованной информации, суммирует бюллетени (без расшифрования) с применением техники гомоморфного сложения, проверяет и выдает заключение о корректности записанных в блокчейн расшифрованных результатах голосования.

Корректность бюллетеня означает:

- Присутствие в нем всех необходимых ячеек с шифртекстами голосов за каждого отдельного кандидата из бюллетени
- Корректность подписи ГОСТ Р 34.10-2012 транзакции бюллетени (проверяется при помощи открытого ключа ГОСТ Р 34.10-2012 голосующего)
- Корректность слепой подписи открытого ключа голосующего (который соответствует подписи транзакции). Эта подпись выдается регистратором и подтверждает, что голосующий имеет право голосовать, т.к. его открытый ключ был подписан вслепую Регистратором (т.е. регистратор не видел, какой открытый ключ он подписывал, хотя знал что голосующий имеет на это право)
- Корректность каждого доказательства с нулевым разглашением range proof (в диапазоне от [0,1]) в каждой ячейке бюллетени. Голосующий может положить в ячейку за каждого кандидата либо 0, либо 1 и зашифровать их. Но ни в коем случае не какое либо другое число - тогда доказательство будет некорректным
- Корректность каждого доказательства с нулевым разглашением range proof для суммы ячеек [1,N]. Число N устанавливается избирательной комиссией для каждого голосования. Голосующий может проголосовать за любое количество кандидатов строго в диапазоне от 1 до N включительно. При этом само число кандидатов, за которых он проголосовал остается известным только самому голосующему, так же, как и выбор кандидатов

Утилита проверяет опубликованные результаты в следующем порядке:

1. Загружает закрытый ключ комиссии commissionPrivKey (который соответствует их открытому ключу commissionPubKey).

2. Загружает результаты работы сервера подсчета, который частично расшифровал суммарную бюллетень
   Это {privDecryptService*sum(R_1_i), zkp_1}, {privDecryptService*sum(R_2_i), zkp_2}, ... , {privDecryptService*sum(R_M_i), zkp_M}  
   где zkp_j - доказательство корректности расшифровки, т.е. по сути доказательство того, что точка privDecryptService*sum(R_j_i), представляет собой именно
   скалярное умножение точки sum(R_j_i) и закрытого ключа privDecryptService (которому соответствует открытый ключ PubDecryptService)
   zkp - zero knowledge proof (доказательство с нулевым разглашением).
   Отметим, что закрытый ключ сервера подсчета не загружается, а загружаются именно его произведения на точки sum(R_1_i), ... , sum(R_M_i) и zkp, которые это подтверждают.

3. Проверяет все M доказательств zkp_j для M ячеек суммарной бюллетени и в случае хотя-бы одного некорректного доказательства выдает ошибку.

4. В случае корректности всех M zkp производится полная расшифровка суммарной бюллетени:

   V_1 = sum(С_1_i) - k1*privDecryptService*sum(R_1_i) - k2*commissionPrivKey*sum(R_1_i),
   V_2 = sum(С_2_i) - k1*privDecryptService*sum(R_2_i) - k2*commissionPrivKey*sum(R_2_i),
   .
   .
   .
   V_M = sum(С_M_i) - k1*privDecryptService*sum(R_M_i) - k2*commissionPrivKey*sum(R_M_i)

   где k1 = Hash(PubDecryptService || commissionPubKey), k2 = Hash(commissionPubKey || PubDecryptService), т.е. коэффициенты с помощью которык вычислялся PubMain, на котором
   шифровались все бюллетени в данном голосовании.


Все эти M точек содержат сумму голосов за каждого из M кандидатов, закодированную в следующем виде:

V_j = voted_for_j*BasePoint

где voted_for_j - число голосов за j-го кандидата, а BasePoint - базовая точка используемой элиптической кривой.

Для решения этих уравнений и получения всех voted_for_j можно использовать метод полного перебора возможных значений voted_for_j (очевидно, что он лежит в диапазоне от 0 (никто не проголосовал за кандидата)
до числа всех проголосовавших с валидными бюллетенями).

Итого, в результате должен получиться результат голосования:

voted_for_1, voted_for_2, ... , voted_for_M

## Установка

- Установите [https://www.docker.com/](Docker)
- Склонируйте этот репозиторий
- Перейдите в корневую директорию утилиты
- Скачайте пакет [КриптоПро CSP 5.0 для Linux (x64, deb)](https://www.cryptopro.ru/products/csp/downloads#latest_csp50r3_linux) и положите файл ```linux-amd64_deb.tgz``` в корневую директорию
- Соберите docker-образ, выполнив команду:<br>```docker build  -t observer-tool -f Dockerfile .```

## Запуск
Для увеличения производительности проверки, увеличьте количество используемых ядер в Docker.
- Проверка транзакций голосования. Перейдите в каталог с zip-архивами транзакций голосований и выполните команду:<br>```docker run --rm -t -i --mount type=bind,source="$(pwd)",target=/app/files,readonly observer-tool run validate [contractId]```
- Для остановки проверки нажмите ```CTRL+C```
